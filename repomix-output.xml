This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
new/
  entities/
    Attachment.ts
    Chat.ts
    Handle.ts
    Message.ts
  fileSystem/
    index.ts
    types.ts
  helpers/
    dateUtils.ts
    utils.ts
  interfaces/
    attachmentInterface.ts
  serializers/
    AttachmentSerializer.ts
    ChatSerializer.ts
    constants.ts
    HandleSerializer.ts
    MessageSerializer.ts
    types.ts
  env.ts
  transformers.ts
  types.ts
webhook/
  index.ts
.gitignore
env.ts
events.ts
index.ts
package.json
tsconfig.json
types.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="new/fileSystem/index.ts">
import * as path from "path";
import * as child_process from "child_process";

import {
    parseMetadataString,
    isNotEmpty,
    isEmpty,
} from "../helpers/utils";

import {
    type AudioMetadata,
    type MetadataKeyMap,
    type VideoMetadata,
    type ImageMetadata,
    AudioMetadataKeys,
    MetadataDataTypes,
    VideoMetadataKeys,
    ImageMetadataKeys
} from "./types";

/**
 * The class used to handle all communications to the App's "filesystem".
 * The filesystem is the directory dedicated to the app-specific files
 */
export class FileSystem {

/**
 * Asynchronously executes a shell command
 */
    static async execShellCommand(cmd: string): Promise<string> {
        const { exec } = child_process;
        return new Promise((resolve, reject) => {
            exec(cmd, (error, stdout, stderr) => {
                if (error) {
                    reject(error);
                }

                resolve(stdout || stderr);
            });
        });
    }


    static getRealPath(filePath: string) {
        let output = filePath;
        if (isEmpty(output)) return output;

        if (output[0] === "~") {
            output = path.join(process.env.HOME, output.slice(1));
        }

        return output;
    }

    static async convertCafToMp3(originalPath: string, outputPath: string): Promise<void> {
        const oldPath = FileSystem.getRealPath(originalPath);
        const output = await FileSystem.execShellCommand(
            `/usr/bin/afconvert -f m4af -d aac "${oldPath}" "${outputPath}"`
        );
        if (isNotEmpty(output) && output.includes("Error:")) {
            throw Error(`Failed to convert audio to MP3: ${output}`);
        }
    }

    static async convertMp3ToCaf(originalPath: string, outputPath: string): Promise<void> {
        const oldPath = FileSystem.getRealPath(originalPath);
        const output = await FileSystem.execShellCommand(
            `/usr/bin/afconvert -f caff -d LEI16@44100 -c 1 "${oldPath}" "${outputPath}"`
        );
        if (isNotEmpty(output) && output.includes("Error:")) {
            throw Error(`Failed to convert audio to CAF: ${output}`);
        }
    }

    static async convertToJpg(originalPath: string, outputPath: string): Promise<void> {
        const oldPath = FileSystem.getRealPath(originalPath);
        const output = await FileSystem.execShellCommand(
            `/usr/bin/sips --setProperty "format" "jpeg" "${oldPath}" --out "${outputPath}"`
        );
        if (isNotEmpty(output) && output.includes("Error:")) {
            throw Error(`Failed to convert image to JPEG: ${output}`);
        }
    }

    static async isSipDisabled(): Promise<boolean> {
        const res = ((await FileSystem.execShellCommand(`csrutil status`)) ?? "").trim();
        return !res.endsWith("enabled.");
    }

    static async hasFullDiskAccess(): Promise<boolean> {
        const res = (
            (await FileSystem.execShellCommand(
                `defaults read ~/Library/Preferences/com.apple.universalaccessAuthWarning.plist`
            )) ?? ""
        ).trim();
        return res.includes('BlueBubbles.app" = 1') || res.includes('BlueBubbles" = 1');
    }

    static async getFileMetadata(filePath: string): Promise<{ [key: string]: string }> {
        try {
            return parseMetadataString(await FileSystem.execShellCommand(`mdls "${FileSystem.getRealPath(filePath)}"`));
        } catch (ex: any) {
            return null;
        }
    }

    private static async parseMetadata(filePath: string, parserKeyDefinition: MetadataKeyMap): Promise<any> {
        const metadata: { [key: string]: string } = await FileSystem.getFileMetadata(filePath);
        if (!metadata) return null;

        const getNumber = (num: string) => {
            if (!num) return null;

            try {
                return Number.parseFloat(num);
            } catch (ex: any) {
                return null;
            }
        };

        const meta: { [key: string]: any } = {};
        for (const [key, value] of Object.entries(metadata)) {
            if (!(key in parserKeyDefinition)) continue;

            // Get the types info for the field
            const { dataType, metaKey } = parserKeyDefinition[key];

            // Parse the item by type
            let itemValue: any;
            switch (dataType) {
                case MetadataDataTypes.Bool:
                    itemValue = value === "1";
                    break;
                case MetadataDataTypes.Float:
                    itemValue = getNumber(value);
                    break;
                case MetadataDataTypes.Int:
                    itemValue = Math.trunc(getNumber(value));
                    break;
                default:
                    itemValue = value;
                    break;
            }

            meta[metaKey] = itemValue;
        }

        return meta;
    }

    static async getAudioMetadata(audioPath: string): Promise<AudioMetadata> {
        const meta = await FileSystem.parseMetadata(audioPath, AudioMetadataKeys);
        return meta as AudioMetadata;
    }

    static async getVideoMetadata(videoPath: string): Promise<VideoMetadata> {
        const meta = await FileSystem.parseMetadata(videoPath, VideoMetadataKeys);
        return meta as VideoMetadata;
    }

    static async getImageMetadata(imagePath: string): Promise<ImageMetadata> {
        const meta = await FileSystem.parseMetadata(imagePath, ImageMetadataKeys);
        return meta as ImageMetadata;
    }










}
</file>

<file path="new/fileSystem/types.ts">
export enum MetadataDataTypes {
    String = 0,
    Int = 1,
    Float = 2,
    Bool = 3
}

export type Metadata = {
    [key: string]: string | number | boolean;
};

export type MetadataKeyMap = {
    [key: string]: MetadataKV;
};

export type MetadataKV = {
    dataType: MetadataDataTypes;
    metaKey: string;
};

export type AudioMetadata = {
    bytes?: number;
    bitRate?: number;
    sampleRate?: number;
    duration?: number;
};

export const AudioMetadataKeys: MetadataKeyMap = {
    kMDItemAudioBitRate: {
        dataType: MetadataDataTypes.Int,
        metaKey: "bitRate"
    },
    kMDItemAudioSampleRate: {
        dataType: MetadataDataTypes.Int,
        metaKey: "sampleRate"
    },
    kMDItemDurationSeconds: {
        dataType: MetadataDataTypes.Float,
        metaKey: "duration"
    },
    kMDItemFSSize: {
        dataType: MetadataDataTypes.Int,
        metaKey: "bytes"
    }
};

export type VideoMetadata = {
    bytes?: number;
    height?: number;
    width?: number;
    audioBitRate?: number;
    videoBitRate?: number;
    duration?: number;
    profileName?: string;
};

export const VideoMetadataKeys: MetadataKeyMap = {
    kMDItemAudioBitRate: {
        dataType: MetadataDataTypes.Int,
        metaKey: "audioBitRate"
    },
    kMDItemVideoBitRate: {
        dataType: MetadataDataTypes.Int,
        metaKey: "videoBitRate"
    },
    kMDItemPixelHeight: {
        dataType: MetadataDataTypes.Int,
        metaKey: "height"
    },
    kMDItemPixelWidth: {
        dataType: MetadataDataTypes.Float,
        metaKey: "width"
    },
    kMDItemFSSize: {
        dataType: MetadataDataTypes.Int,
        metaKey: "bytes"
    },
    kMDItemDurationSeconds: {
        dataType: MetadataDataTypes.Float,
        metaKey: "duration"
    },
    kMDItemProfileName: {
        dataType: MetadataDataTypes.String,
        metaKey: "profileName"
    }
};

export type ImageMetadata = {
    altitude?: number;
    aperture?: number;
    bitsPerSample?: number;
    colorSpace?: string;
    exposureTimeSeconds?: number;
    withFlash?: boolean;
    focalLength?: number;
    size?: number;
    latitude?: number;
    longitude?: number;
    orientation?: number;
    height?: number;
    width?: number;
    pixelCount?: number;
    withRedEye?: boolean;
    heightDpi?: number;
    widthDpi?: number;
    withWhiteBalance?: boolean;
    profileName?: string;
    deviceMake?: string;
    deviceModel?: string;
};

export const ImageMetadataKeys: MetadataKeyMap = {
    kMDItemAcquisitionMake: {
        dataType: MetadataDataTypes.String,
        metaKey: "deviceMake"
    },
    kMDItemAcquisitionModel: {
        dataType: MetadataDataTypes.String,
        metaKey: "deviceModel"
    },
    kMDItemAltitude: {
        dataType: MetadataDataTypes.Float,
        metaKey: "altitude"
    },
    kMDItemAperture: {
        dataType: MetadataDataTypes.Float,
        metaKey: "aperture"
    },
    kMDItemBitsPerSample: {
        dataType: MetadataDataTypes.Int,
        metaKey: "bitsPerSample"
    },
    kMDItemColorSpace: {
        dataType: MetadataDataTypes.String,
        metaKey: "colorSpace"
    },
    kMDItemExposureTimeSeconds: {
        dataType: MetadataDataTypes.Float,
        metaKey: "exposureTimeSeconds"
    },
    kMDItemFlashOnOff: {
        dataType: MetadataDataTypes.Bool,
        metaKey: "withFlash"
    },
    kMDItemFocalLength: {
        dataType: MetadataDataTypes.Float,
        metaKey: "focalLength"
    },
    kMDItemFSSize: {
        dataType: MetadataDataTypes.Int,
        metaKey: "size"
    },
    kMDItemLatitude: {
        dataType: MetadataDataTypes.Float,
        metaKey: "latitude"
    },
    kMDItemLongitude: {
        dataType: MetadataDataTypes.Float,
        metaKey: "longitude"
    },
    kMDItemOrientation: {
        dataType: MetadataDataTypes.Int,
        metaKey: "orientation"
    },
    kMDItemPixelHeight: {
        dataType: MetadataDataTypes.Int,
        metaKey: "height"
    },
    kMDItemPixelWidth: {
        dataType: MetadataDataTypes.Int,
        metaKey: "width"
    },
    kMDItemPixelCount: {
        dataType: MetadataDataTypes.Int,
        metaKey: "pixelCount"
    },
    kMDItemRedEyeOnOff: {
        dataType: MetadataDataTypes.Bool,
        metaKey: "withRedEye"
    },
    kMDItemResolutionWidthDPI: {
        dataType: MetadataDataTypes.Int,
        metaKey: "widthDpi"
    },
    kMDItemResolutionHeightDPI: {
        dataType: MetadataDataTypes.Int,
        metaKey: "heightDpi"
    },
    kMDItemWhiteBalance: {
        dataType: MetadataDataTypes.Bool,
        metaKey: "withWhiteBalance"
    },
    kMDItemProfileName: {
        dataType: MetadataDataTypes.String,
        metaKey: "profileName"
    }
};
</file>

<file path="new/interfaces/attachmentInterface.ts">
import { isNotEmpty } from "../helpers/utils";
import type { Attachment } from "../entities/Attachment";
import { isEmpty } from "../helpers/utils";
import { FileSystem } from "../fileSystem";
import * as fs from "fs";

export class AttachmentInterface {
    static livePhotoExts = ["png", "jpeg", "jpg", "heic", "tiff"];


    static getLivePhotoPath(attachment: Attachment): string | null {
        // If we don't have a path, return null
        const fPath = attachment?.filePath;
        if (isEmpty(fPath)) return null;

        // Get the existing extension (if any).
        // If it's been converted, it'll have a double-extension.
        let ext = fPath.includes('.heic.jpeg') ? 'heic.jpeg' : fPath.split(".").pop() ?? "";

        // If the extension is not an image extension, return null
        if (!AttachmentInterface.livePhotoExts.includes(ext.toLowerCase())) return null;

        // Escape periods in the extension for the regex
        ext = ext.replace(/\./g, "\\.");
    
        // Get the path to the live photo
        // Replace the extension with .mov, or add it if there is no extension
        const livePath = isNotEmpty(ext) ? fPath.replace(new RegExp(`\\.${ext}$`), ".mov") : `${fPath}.mov`;
        const realPath = FileSystem.getRealPath(livePath);

        // If the live photo doesn't exist, return null
        if (!fs.existsSync(realPath)) return null;

        // If the .mov file exists, return the path
        return realPath;
    }
}
</file>

<file path="new/entities/Attachment.ts">
import { Entity, PrimaryGeneratedColumn, Column, ManyToMany, JoinTable } from "typeorm";
import { Message } from "./Message";
import { isEmpty } from "../helpers/utils";
import { isMinSierra, isMinHighSierra } from "../env";
import { conditional } from "conditional-decorator";
import * as mime from "mime-types";
import { BooleanTransformer, MessagesDateTransformer, AttributedBodyTransformer } from "../transformers";

import * as path from "path";
function getRealPath(filePath: string) {
    let output = filePath;
    if (isEmpty(output)) return output;

    if (output[0] === "~") {
        output = path.join(process.env.HOME, output.slice(1));
    }

    return output;
}

@Entity("attachment")
export class Attachment {
    @PrimaryGeneratedColumn({ name: "ROWID" })
    ROWID: number;

    @ManyToMany(type => Message)
    @JoinTable({
        name: "message_attachment_join",
        joinColumns: [{ name: "attachment_id" }],
        inverseJoinColumns: [{ name: "message_id" }]
    })
    messages: Message[];

    @Column({ type: "text", nullable: false })
    guid: string;

    @Column({
        type: "integer",
        name: "created_date",
        default: 0,
        transformer: MessagesDateTransformer
    })
    createdDate: Date;

    @Column({
        type: "integer",
        name: "start_date",
        default: 0,
        transformer: MessagesDateTransformer
    })
    startDate: Date;

    @Column({ type: "text", name: "filename", nullable: false })
    filePath: string;

    @Column({ type: "text", nullable: false })
    uti: string;

    @Column({ type: "text", name: "mime_type", nullable: true })
    mimeType: string;

    @Column({ type: "integer", name: "transfer_state", default: 0 })
    transferState: number;

    @Column({
        type: "integer",
        name: "is_outgoing",
        default: 0,
        transformer: BooleanTransformer
    })
    isOutgoing: boolean;

    @Column({
        type: "blob",
        name: "user_info",
        nullable: true,
        transformer: AttributedBodyTransformer
    })
    userInfo: NodeJS.Dict<any>[] | null;

    @Column({ type: "text", name: "transfer_name", nullable: false })
    transferName: string;

    @Column({ type: "integer", name: "total_bytes", default: 0 })
    totalBytes: number;

    @conditional(
        isMinSierra,
        Column({
            type: "integer",
            name: "is_sticker",
            default: 0,
            transformer: BooleanTransformer
        })
    )
    isSticker: boolean;

    @conditional(
        isMinSierra,
        Column({
            type: "blob",
            name: "sticker_user_info",
            nullable: true
        })
    )
    stickerUserInfo: Blob;

    @conditional(
        isMinSierra,
        Column({
            type: "blob",
            name: "attribution_info",
            nullable: true,
            transformer: AttributedBodyTransformer
        })
    )
    attributionInfo: NodeJS.Dict<any>[] | null;

    @conditional(
        isMinSierra,
        Column({
            type: "integer",
            name: "hide_attachment",
            default: 0,
            transformer: BooleanTransformer
        })
    )
    hideAttachment: boolean;

    @conditional(
        isMinHighSierra,
        Column({
            type: "text",
            unique: true,
            name: "original_guid"
        })
    )
    originalGuid: string;

    private getMimeTypeFromUserInfo(): string | null {
        if (isEmpty(this.userInfo)) return null;
        return this.userInfo[0]['mime-type'] ?? null;
    }

    getDimensions(): { height: number, width: number } | null {
        if (isEmpty(this.attributionInfo)) return null;
        const height = this.attributionInfo[0]?.pgensh;
        const width = this.attributionInfo[0]?.pgensw;
        if (!height || !width) return null;
        return { height, width };
    }

    getMimeType(): string {
        const fPath = getRealPath(this.filePath);
        let mType = this.mimeType ?? this.getMimeTypeFromUserInfo() ?? mime.lookup(fPath);
        if (!mType || isEmpty(mType as any)) mType = "application/octet-stream";
        return mType;
    }
}
</file>

<file path="new/entities/Chat.ts">
import { Entity, PrimaryGeneratedColumn, Column, ManyToMany, JoinTable } from "typeorm";
import { Handle } from "./Handle";
import { Message } from "./Message";
import { AttributedBodyTransformer, MessagesDateTransformer, BooleanTransformer } from "../transformers";
import { isMinHighSierra } from "../env";
import { conditional } from "conditional-decorator";

@Entity("chat")
export class Chat {
    @PrimaryGeneratedColumn({ name: "ROWID" })
    ROWID: number;

    @ManyToMany(type => Handle)
    @JoinTable({
        name: "chat_handle_join",
        joinColumns: [{ name: "chat_id" }],
        inverseJoinColumns: [{ name: "handle_id" }]
    })
    participants: Handle[];

    @ManyToMany(type => Message)
    @JoinTable({
        name: "chat_message_join",
        joinColumns: [{ name: "chat_id" }],
        inverseJoinColumns: [{ name: "message_id" }]
    })
    messages: Message[];

    @Column({ type: "text", nullable: false })
    guid: string;

    @Column({ type: "integer", nullable: true })
    style: number;

    @Column({ type: "integer", nullable: true })
    state: number;

    @Column({ name: "account_id", type: "text", nullable: true })
    accountId: number;

    @Column({
        type: "blob",
        nullable: true,
        transformer: AttributedBodyTransformer
    })
    properties: NodeJS.Dict<any>[] | null;

    @Column({ name: "chat_identifier", type: "text", nullable: true })
    chatIdentifier: string;

    @Column({ name: "service_name", type: "text", nullable: true })
    serviceName: string;

    @Column({ name: "room_name", type: "text", nullable: true })
    roomName: string;

    @Column({ name: "account_login", type: "text", nullable: true })
    accountLogin: string;

    @Column({
        name: "is_archived",
        type: "integer",
        nullable: true,
        transformer: BooleanTransformer
    })
    isArchived: boolean;

    @conditional(
        isMinHighSierra,
        Column({
            name: "last_read_message_timestamp",
            type: "date",
            transformer: MessagesDateTransformer,
            default: 0
        })
    )
    lastReadMessageTimestamp: Date;

    @Column({ name: "last_addressed_handle", type: "text", nullable: true })
    lastAddressedHandle: string;

    @Column({ name: "display_name", type: "text", nullable: true })
    displayName: string;

    @Column({ name: "group_id", type: "text", nullable: true })
    groupId: string;

    @Column({
        name: "is_filtered",
        type: "integer",
        nullable: true,
        transformer: BooleanTransformer
    })
    isFiltered: boolean;

    @Column({
        name: "successful_query",
        type: "integer",
        nullable: true,
        transformer: BooleanTransformer
    })
    successfulQuery: boolean;

    get isGroup() {
        return this.style === 43;
    }
}
</file>

<file path="new/entities/Handle.ts">
import { Entity, PrimaryGeneratedColumn, Column, OneToMany, JoinColumn, JoinTable, ManyToMany } from "typeorm";
import { Message } from "./Message";
import { Chat } from "./Chat";

@Entity("handle")
export class Handle {
    @PrimaryGeneratedColumn({ name: "ROWID" })
    ROWID: number;

    @OneToMany(type => Message, message => message.handle)
    @JoinColumn({ name: "ROWID", referencedColumnName: "handle_id" })
    messages: Message[];

    @ManyToMany(type => Chat)
    @JoinTable({
        name: "chat_handle_join",
        joinColumns: [{ name: "handle_id" }],
        inverseJoinColumns: [{ name: "chat_id" }]
    })
    chats: Chat[];

    @Column({ type: "text", nullable: false })
    id: string;

    @Column({ type: "text", nullable: true })
    country: string;

    @Column({ type: "text", nullable: false, default: "iMessage" })
    service: string;

    @Column({ name: "uncanonicalized_id", type: "text", nullable: true })
    uncanonicalizedId: string;
}
</file>

<file path="new/entities/Message.ts">
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, JoinTable, JoinColumn, ManyToMany } from "typeorm";
import { conditional } from "conditional-decorator";

import { BooleanTransformer, MessagesDateTransformer, MessageTypeTransformer, AttributedBodyTransformer } from "../transformers";
import { Handle } from "./Handle";
import { Chat } from "./Chat";
import { Attachment } from "./Attachment";
import { isEmpty, isNotEmpty, sanitizeStr, AttributedBodyUtils } from "../helpers/utils";
import { isMinBigSur, isMinCatalina, isMinHighSierra, isMinMonterey, isMinSierra, isMinVentura } from "../env";
import { NSAttributedString } from "node-typedstream";

@Entity("message")
export class Message {
    universalText(sanitize = false): string | null {
        let text = this.text;
        const attributedText = AttributedBodyUtils.extractText(this.attributedBody);
        if (isEmpty(text) && !isEmpty(attributedText)) {
            text = attributedText;
        }

        return sanitize ? sanitizeStr(text) : text;
    }

    contentString(maxText = 15): string {
        let text = this.universalText(true) ?? "";
        const textLen = text.length;
        const attachments = this.attachments ?? [];
        const attachmentsLen = attachments.length;
        let subject = this.subject ?? "";
        const subjectLen = subject.length;

        // Build the content
        const parts = [];

        // If we have text, add it, but with the max length taken into account
        if (textLen > 0) {
            if (textLen > maxText) {
                text = `${text.substring(0, maxText)}...`;
            }

            parts.push(`"${text}"`);
        } else {
            parts.push(`<No Text>`);
        }

        // If we have a subject, add it, but with the max length taken into account
        if (subjectLen > 0) {
            if (subjectLen > maxText) {
                subject = `${subject.substring(0, maxText)}...`;
            }

            parts.push(`Subject: "${subject}"`);
        }

        // If we have attachments, print those out
        if (attachmentsLen > 0) parts.push(`Attachments: ${attachmentsLen}`);

        // Lastly, add the date
        parts.push(`Date: ${this.dateCreated.toLocaleString()}`);

        return parts.join("; ");
    }

    get retractedParts(): number[] {
        return this.messageSummaryInfo?.[0]?.retractedParts ?? [];
    }

    get hasUnsentParts(): boolean {
        return this.dateEdited && isNotEmpty(this.retractedParts, false);
    }

    get isFullyUnsent(): boolean {
        // It's fully unsent if we have unsent parts, and all parts are unsent
        return this.hasUnsentParts && this.retractedParts.length > 0 && this.partCount === 0;
    }

    get isPartiallyUnsent(): boolean {
        // It's partially unsent if we have unsent parts, but there are still parts left
        return this.hasUnsentParts && this.retractedParts.length > 0 && this.partCount > 0;
    }

    get lastUpdateTime(): Date {
        return this.dateRetracted ?? this.dateEdited ?? this.dateRead ?? this.dateDelivered ?? this.dateCreated;
    }

    get messageStatus(): String {
        return this.dateRetracted
            ? "Unsent"
            : this.isFullyUnsent
            ? "Unsent"
            : this.isPartiallyUnsent
            ? "Partially Unsent"
            : this.dateEdited
            ? "Edited"
            : this.dateRead
            ? "Read"
            : this.dateDelivered
            ? "Delivered"
            : "Sent";
    }

    @PrimaryGeneratedColumn({ name: "ROWID" })
    ROWID: number;

    @Column({ type: "text", nullable: false })
    guid: string;

    @Column({ type: "text", nullable: true })
    text: string;

    @Column({ type: "integer", nullable: true, default: 0 })
    replace: number;

    @Column({
        name: "service_center",
        type: "text",
        nullable: true
    })
    serviceCenter: string;

    @ManyToOne(type => Handle)
    @JoinColumn({ name: "handle_id", referencedColumnName: "ROWID" })
    handle: Handle;

    @ManyToMany(type => Chat)
    @JoinTable({
        name: "chat_message_join",
        joinColumns: [{ name: "message_id" }],
        inverseJoinColumns: [{ name: "chat_id" }]
    })
    chats: Chat[];

    @ManyToMany(type => Attachment)
    @JoinTable({
        name: "message_attachment_join",
        joinColumns: [{ name: "message_id" }],
        inverseJoinColumns: [{ name: "attachment_id" }]
    })
    attachments: Attachment[];

    @Column({ name: "handle_id", type: "integer", nullable: true, default: 0 })
    handleId: number;

    @Column({ type: "text", nullable: true })
    subject: string;

    @Column({ type: "text", nullable: true })
    country: string;

    @Column({
        type: "blob",
        nullable: true,
        transformer: AttributedBodyTransformer
    })
    attributedBody: NSAttributedString[] | null;

    @Column({ type: "integer", nullable: true, default: 0 })
    version: number;

    @Column({ type: "integer", nullable: true, default: 0 })
    type: number;

    @Column({ type: "text", nullable: true, default: "iMessage" })
    service: string;

    @Column({ type: "text", nullable: true })
    account: string;

    @Column({ name: "account_guid", type: "text", nullable: true })
    accountGuid: string;

    @Column({
        type: "integer",
        nullable: true,
        default: 0
    })
    error: number;

    @Column({
        name: "date",
        type: "date",
        nullable: true,
        transformer: MessagesDateTransformer
    })
    dateCreated: Date;

    @Column({
        name: "date_read",
        type: "date",
        nullable: true,
        transformer: MessagesDateTransformer
    })
    dateRead: Date;

    @Column({
        name: "date_delivered",
        type: "date",
        nullable: true,
        transformer: MessagesDateTransformer
    })
    dateDelivered: Date;

    @Column({
        name: "is_delivered",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isDelivered: boolean;

    @Column({
        name: "is_finished",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isFinished: boolean;

    @Column({
        name: "is_emote",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isEmote: boolean;

    @Column({
        name: "is_from_me",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isFromMe: boolean;

    @Column({
        name: "is_empty",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isEmpty: boolean;

    @Column({
        name: "is_delayed",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isDelayed: boolean;

    @Column({
        name: "is_auto_reply",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isAutoReply: boolean;

    @Column({
        name: "is_prepared",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isPrepared: boolean;

    @Column({
        name: "is_read",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isRead: boolean;

    @Column({
        name: "is_system_message",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isSystemMessage: boolean;

    @Column({
        name: "is_sent",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isSent: boolean;

    @Column({
        name: "has_dd_results",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    hasDdResults: boolean;

    @Column({
        name: "is_service_message",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isServiceMessage: boolean;

    @Column({
        name: "is_forward",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isForward: boolean;

    @Column({
        name: "was_downgraded",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    wasDowngraded: boolean;

    @Column({
        name: "is_archive",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isArchived: boolean;

    @Column({
        name: "cache_has_attachments",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    cacheHasAttachments: boolean;

    @Column({ name: "cache_roomnames", type: "text", nullable: true })
    cacheRoomnames: string;

    @Column({
        name: "was_data_detected",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    wasDataDetected: boolean;

    @Column({
        name: "was_deduplicated",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    wasDeduplicated: boolean;

    @Column({
        name: "is_audio_message",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isAudioMessage: boolean;

    @Column({
        name: "is_played",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isPlayed: boolean;

    @Column({
        name: "date_played",
        type: "integer",
        transformer: MessagesDateTransformer,
        default: 0
    })
    datePlayed: Date;

    @Column({ name: "item_type", type: "integer", default: 0 })
    itemType: number;

    @Column({
        name: "other_handle",
        type: "integer",
        nullable: true,
        default: 0
    })
    otherHandle: number;

    @Column({ name: "group_title", type: "text" })
    groupTitle: string;

    @Column({ name: "group_action_type", type: "integer", default: 0 })
    groupActionType: number;

    @Column({ name: "share_status", type: "integer", default: 0 })
    shareStatus: number;

    @Column({ name: "share_direction", type: "integer", default: 0 })
    shareDirection: number;

    @Column({
        name: "is_expirable",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isExpirable: boolean;

    @Column({
        name: "expire_state",
        type: "integer",
        transformer: BooleanTransformer,
        default: 0
    })
    isExpired: boolean;

    @Column({
        name: "message_action_type",
        type: "integer",
        default: 0
    })
    messageActionType: number;

    @Column({
        name: "message_source",
        type: "integer",
        default: 0
    })
    messageSource: number;

    @conditional(
        isMinSierra,
        Column({
            name: "associated_message_guid",
            type: "text",
            nullable: true
        })
    )
    associatedMessageGuid: string;

    @conditional(
        isMinSierra,
        Column({
            name: "associated_message_type",
            type: "text",
            transformer: MessageTypeTransformer,
            nullable: true
        })
    )
    associatedMessageType: string;

    @conditional(isMinHighSierra, Column({ name: "balloon_bundle_id", type: "text", nullable: true }))
    balloonBundleId: string;

    @conditional(
        isMinHighSierra,
        Column({
            name: "payload_data",
            type: "blob",
            nullable: true,
            transformer: AttributedBodyTransformer
        })
    )
    payloadData: NodeJS.Dict<any>[] | null;

    @conditional(isMinHighSierra, Column({ name: "expressive_send_style_id", type: "text", nullable: true }))
    expressiveSendStyleId: string;

    @conditional(
        isMinHighSierra,
        Column({
            name: "associated_message_range_location",
            type: "integer",
            default: 0
        })
    )
    associatedMessageRangeLocation: number;

    @conditional(
        isMinHighSierra,
        Column({
            name: "associated_message_range_length",
            type: "integer",
            default: 0
        })
    )
    associatedMessageRangeLength: number;

    @conditional(
        isMinHighSierra,
        Column({
            name: "time_expressive_send_played",
            type: "integer",
            transformer: MessagesDateTransformer,
            default: 0
        })
    )
    timeExpressiveSendPlayed: Date;

    @conditional(
        isMinHighSierra,
        Column({
            name: "message_summary_info",
            type: "blob",
            nullable: true,
            transformer: AttributedBodyTransformer
        })
    )
    messageSummaryInfo: NodeJS.Dict<any>[] | null;

    @conditional(
        isMinCatalina,
        Column({
            name: "reply_to_guid",
            type: "text",
            nullable: true
        })
    )
    replyToGuid: string;

    @conditional(
        isMinCatalina,
        Column({
            name: "is_corrupt",
            type: "integer",
            transformer: BooleanTransformer,
            default: 0
        })
    )
    isCorrupt: boolean;

    @conditional(
        isMinCatalina,
        Column({
            name: "is_spam",
            type: "integer",
            transformer: BooleanTransformer,
            default: 0
        })
    )
    isSpam: boolean;

    @conditional(
        isMinBigSur,
        Column({
            name: "thread_originator_guid",
            type: "text",
            nullable: true
        })
    )
    threadOriginatorGuid: string;

    @conditional(
        isMinBigSur,
        Column({
            name: "thread_originator_part",
            type: "text",
            nullable: true
        })
    )
    threadOriginatorPart: string;

    @conditional(
        isMinVentura,
        Column({
            name: "date_retracted",
            type: "date",
            transformer: MessagesDateTransformer,
            default: 0
        })
    )
    dateRetracted: Date;

    @conditional(
        isMinVentura,
        Column({
            name: "date_edited",
            type: "date",
            transformer: MessagesDateTransformer,
            default: 0
        })
    )
    dateEdited: Date;

    @conditional(
        isMinVentura,
        Column({
            name: "part_count",
            type: "integer",
            default: null
        })
    )
    partCount: number;

    @conditional(
        isMinMonterey,
        Column({
            name: "was_delivered_quietly",
            type: "integer",
            transformer: BooleanTransformer,
            default: 0
        })
    )
    wasDeliveredQuietly: boolean;

    @conditional(
        isMinMonterey,
        Column({
            name: "did_notify_recipient",
            type: "integer",
            transformer: BooleanTransformer,
            default: 0
        })
    )
    didNotifyRecipient: boolean;

    get isDigitalTouch(): boolean {
        return this.balloonBundleId === "com.apple.DigitalTouchBalloonProvider";
    }

    get isHandwritten(): boolean {
        return this.balloonBundleId === "com.apple.Handwriting.HandwritingProvider";
    }
}
</file>

<file path="new/helpers/dateUtils.ts">
import { macOSVersion } from "macos-version";
import { compareVersions } from "compare-versions";

const osVersion = macOSVersion();
const MULTIPLIER = 10 ** 6;

/**
 * Gets the seconds since Jan 1st, 2001. We need this because apple uses this
 * as their EPOCH time, rather than the true EPOCH
 */
export const get2001Time = (): number => {
    const appleEpoch = new Date("01-01-2001 00:00:00-0:00");
    return appleEpoch.getTime();
};

/**
 * Converts a seconds-since-2001 timestamp to a date object
 *
 * @param timestamp The seconds-since-2001
 */
export const getDateUsing2001 = (timestamp: number, multiplier = MULTIPLIER): Date => {
    if (timestamp === 0 || timestamp == null) return null;

    try {
        let ts = get2001Time();
        if (!osVersion || compareVersions(osVersion, "10.13.0") >= 0) {
            ts += timestamp / multiplier;
        } else {
            ts += timestamp * 1000;
        }

        return new Date(ts);
    } catch (e: any) {
        console.log(e.message);
        return null;
    }
};

export const getCocoaDate = (timestamp: number): Date => {
    if (timestamp === 0 || timestamp == null) return null;

    try {
        let ts = get2001Time();
        ts += timestamp * 1000;
        return new Date(ts);
    } catch (e: any) {
        console.log(e.message);
        return null;
    }
};

/**
 * Converts a date object to a seconds-since-2001 timestamp
 *
 * @param timestamp The date object to convert
 */
export const convertDateTo2001Time = (date: Date): number => {
    if (date === null) return 0;

    try {
        let ts = date.getTime() - get2001Time();
        if (!osVersion || compareVersions(osVersion, "10.13.0") >= 0) ts *= MULTIPLIER;
        else ts /= 1000;

        return ts;
    } catch (e: any) {
        console.log(e.message);
        return null;
    }
};

export const convertDateToCocoaTime = (date: Date): number => {
    if (date === null) return 0;

    try {
        let ts = date.getTime() - get2001Time();
        ts /= 1000;
        return ts;
    } catch (e: any) {
        console.log(e.message);
        return null;
    }
};
</file>

<file path="new/helpers/utils.ts">
import { NSAttributedString, Unarchiver } from "node-typedstream";

export const MessagesBasePath = `${process.env.HOME}/Library/Messages`;
export const invisibleMediaChar = String.fromCharCode(65532);




export const isEmpty = (value: string | Array<any> | NodeJS.Dict<any> | number | null | undefined, trim = true): boolean => {
    return !isNotEmpty(value, trim);
};


export const isNotEmpty = (value: string | Array<any> | NodeJS.Dict<any> | number | null | undefined, trimEmpty = true ): boolean => {
    if (!value) return false;

    // Handle if the input is a string
    if (typeof value === "string" && (trimEmpty ? (value as string).trim() : value).length > 0) return true;

    // Handle if the input is a list
    if (typeof value === "object" && Array.isArray(value)) {
        if (trimEmpty) return value.filter(i => isNotEmpty(i)).length > 0;
        return value.length > 0;
    }

    // Handle if the input is a dictionary
    if (typeof value === "object" && !Array.isArray(value)) return Object.keys(value).length > 0;

    // If all fails, it's not empty
    return true;
};

export const convertAttributedBody = (value: Buffer): any[] => {
    if (isEmpty(value)) return null;

        try {
            const attributedBody = Unarchiver.open(value, Unarchiver.BinaryDecoding.decodable).decodeAll();
            if (isEmpty(attributedBody)) return null;

            let body = null;
            if (Array.isArray(attributedBody)) {
                body = attributedBody.map(i => {
                    if (i.values) {
                        return i.values.filter((e: any) => {
                            return e && e instanceof NSAttributedString;
                        });
                    } else {
                        return i;
                    }
                });
            } else {
                body = attributedBody;
            }

            // Make sure we don't have nested arrays
            if (Array.isArray(body)) {
                body = body.flat();
            }

            // Make sure all outputs are arrays
            if (!Array.isArray(body)) {
                body = [body];
            }

            return body;
        } catch (e: any) {
            console.log(`Failed to deserialize archive: ${e.message}`);
        }

        return null;
    }




export const sanitizeStr = (val: string) => {
    if (!val) return val;

    // Recursively replace all "obj" hidden characters
    let output = val;
    while (output.includes(invisibleMediaChar)) {
        output = output.replace(invisibleMediaChar, "");
    }

    return safeTrim(output);
};

export const safeTrim = (value: string) => {
    return (value ?? "").trim();
};

export class AttributedBodyUtils {
    static extractText(attributedBody: NodeJS.Dict<any> | NodeJS.Dict<any>[]): string | null {
        if (attributedBody == null) return null;
        if (!Array.isArray(attributedBody)) {
            attributedBody = [attributedBody];
        }

        for (const i of (attributedBody as NodeJS.Dict<any>[])) {
            if (isNotEmpty(i?.string)) {
                return i.string;
            }
        }
        
        return null;
    }
}



// Ugly stuff
import { Attachment } from "../entities/Attachment";
import { FileSystem } from "../fileSystem";
import type { Metadata } from "../fileSystem/types";
import * as fs from "fs";
import { basename } from "path";


export const MAX_FILE_SIZE = 157286400;
export const handledImageMimes = ["image/jpeg", "image/jpg", "image/png", "image/bmp", "image/tiff", "image/gif"];

export const getConversionPath = (attachment: Attachment, extension: string): string => {
    const guid = attachment.originalGuid ?? attachment.guid;
    const newDir = `${FileSystem.convertDir}/${guid}`;
    if (!fs.existsSync(newDir)) fs.mkdirSync(newDir, { recursive: true });
    const newName = isEmpty(attachment.transferName) ? guid : attachment.transferName;

    // If the path already has the extension, return it
    let newPath = `${newDir}/${newName}`;
    if (newPath.endsWith(`.${extension}`)) return newPath;

    // Otherwise, return the path with the extension
    return `${newDir}/${newName}.${extension}`;
}

export const convertAudio = async (
    attachment: Attachment,
    {
        originalMimeType = null,
        dryRun = false
    }: {
        originalMimeType?: string,
        dryRun?: boolean
    } = {}
): Promise<string | null> => {
    if (!attachment) return null;
    const newPath = getConversionPath(attachment, "mp3");
    const mType = originalMimeType ?? attachment.getMimeType();
    let failed = false;
    let ext = null;

    if (attachment.uti === "com.apple.coreaudio-format" || mType == "audio/x-caf") {
        ext = "caf";
    }

    if (!fs.existsSync(newPath) && !dryRun) {
        try {
            if (isNotEmpty(ext)) {
                console.log(`Converting attachment, ${attachment.transferName}, to an MP3...`);
                await FileSystem.convertCafToMp3(attachment.filePath, newPath);
            }
        } catch (ex: any) {
            failed = true;
            console.log(`Failed to convert CAF to MP3 for attachment, ${attachment.transferName}`, "debug");
            console.log(ex?.message ?? ex, "error");
        }
    } else {
        console.log("Attachment has already been converted! Skipping...", "debug");
    }

    if (!failed && ext && (fs.existsSync(newPath) || dryRun)) {
        // If conversion is successful, we need to modify the attachment a bit
        attachment.mimeType = "audio/mp3";
        attachment.filePath = newPath;
        attachment.transferName = basename(newPath).replace(`.${ext}`, ".mp3");

        // Set the fPath to the newly converted path
        return newPath;
    }

    return null;
};

export const convertImage = async (
    attachment: Attachment,
    {
        originalMimeType = null,
        dryRun = false
    }: {
        originalMimeType?: string
        dryRun?: boolean
    } = {}
): Promise<string> => {
    if (!attachment) return null;
    const newPath = getConversionPath(attachment, "jpeg");
    const mType = originalMimeType ?? attachment.getMimeType();
    let failed = false;
    let ext: string = null;

    // Only convert certain types
    if (attachment.uti === "public.heic" || mType.startsWith("image/heic")) {
        ext = "heic";
    } else if (attachment.uti === "public.heif" || mType.startsWith("image/heif")) {
        ext = "heif";
    } else if (attachment.uti === "public.tiff" || mType.startsWith("image/tiff") || mType.endsWith("tif")) {
        ext = "tiff";
    }

    if (!fs.existsSync(newPath) && !dryRun) {
        try {
            if (isNotEmpty(ext)) {
                console.log(`Converting image attachment, ${attachment.transferName}, to an JPEG...`);
                await FileSystem.convertToJpg(attachment.filePath, newPath);
            }
        } catch (ex: any) {
            failed = true;
            console.log(`Failed to convert image to JPEG for attachment, ${attachment.transferName}`, "debug");
            console.log(ex?.message ?? ex, "error");
        }
    } else {
        console.log("Attachment has already been converted! Skipping...", "debug");
    }

    if (!failed && ext && (fs.existsSync(newPath) || dryRun)) {
        // If conversion is successful, we need to modify the attachment a bit
        attachment.mimeType = "image/jpeg";
        attachment.filePath = newPath;
        attachment.transferName = basename(newPath).replace(new RegExp(`\\.${ext}$`), ".jpeg");

        // Set the fPath to the newly converted path
        return newPath;
    }

    return null;
};

export const getAttachmentMetadata = async (attachment: Attachment): Promise<Metadata> => {
    let metadata: Metadata = {};
    if (attachment.uti !== "com.apple.coreaudio-format" && !attachment.mimeType) return metadata;

    if (attachment.uti === "com.apple.coreaudio-format" || attachment.mimeType.startsWith("audio")) {
        metadata = await FileSystem.getAudioMetadata(attachment.filePath);
    } else if (attachment.mimeType.startsWith("image")) {
        metadata = await FileSystem.getImageMetadata(attachment.filePath);

        // Try to get the dimentions from the attachment object iself (attribution info)
        const dimensions = attachment.getDimensions();
        if (dimensions) {
            metadata.height = dimensions.height;
            metadata.width = dimensions.width;
        }

        try {
            // If we got no height/width data, let's try to fallback to other code to fetch it
            if (handledImageMimes.includes(attachment.mimeType) && (!metadata?.height || !metadata?.width)) {
                console.log("Image metadata empty, getting size from NativeImage...", "debug");

                // Load the image data
                // TODO - remove the NativeImage and do it without electron
                const image = nativeImage.createFromPath(FileSystem.getRealPath(attachment.filePath));

                // If we were able to load the image, get the size
                if (image) {
                    const size = image.getSize();

                    // If the size if available, set the metadata for it
                    if (size?.height && size?.width) {
                        // If the metadata is null, let's give it some data
                        if (metadata === null) metadata = {};
                        metadata.height = size.height;
                        metadata.width = size.width;
                    }
                }
            }
        } catch (ex: any) {
            console.log("Failed to load size data from NativeImage!", "debug");
        }
    } else if (attachment.mimeType.startsWith("video")) {
        metadata = await FileSystem.getVideoMetadata(attachment.filePath);
    }

    return metadata;
};

// TODO - remove the NativeImage and do it without electron
import { encode as blurhashEncode } from "blurhash";
export const getBlurHash = async ({
    image,
    width = null,
    height = null,
    quality = "good",
    componentX = 3,
    componentY = 3
}: {
    image: NativeImage;
    height?: number;
    width?: number;
    quality?: "good" | "better" | "best";
    componentX?: number;
    componentY?: number;
}): Promise<string> => {
    const resizeOpts: Electron.ResizeOptions = { quality };
    if (width) resizeOpts.width = width;
    if (height) resizeOpts.height = height;

    // Resize the image (with new quality and size if applicable)
    const calcImage: NativeImage = image.resize({ width, quality: "good" });
    const size = calcImage.getSize();

    // Compute and return blurhash
    return blurhashEncode(
        Uint8ClampedArray.from(calcImage.toBitmap()),
        size.width,
        size.height,
        componentX,
        componentY
    );
};


export const resultAwaiter = async ({
    maxWaitMs = 30000,
    initialWaitMs = 250,
    waitMultiplier = 1.5,
    getData,
    extraLoopCondition = null,
    dataLoopCondition = null
}: {
    maxWaitMs?: number;
    initialWaitMs?: number;
    waitMultiplier?: number;
    getData: (previousData: any | null) => any;
    extraLoopCondition?: (data: any | null) => boolean;
    dataLoopCondition?: (data: any | null) => boolean;
}): Promise<any | null> => {
    let waitTime = initialWaitMs;
    let totalTime = 0;

    // Defaults to false because true means keep looping.
    // This condition is OR'd with the data loop condition.
    // If this was true, it would keep looping indefinitely.
    if (!extraLoopCondition) {
        extraLoopCondition = _ => false;
    }

    // Set the default check for the loop condition to be if the data is null.
    // If it's null, keep looping.
    if (!dataLoopCondition) {
        dataLoopCondition = _ => !data;
    }

    let data = await getData(null);
    while ((dataLoopCondition(data) || extraLoopCondition(data)) && totalTime < maxWaitMs) {
        // Give it a bit to execute
        await waitMs(waitTime);
        totalTime += waitTime;

        // Re-fetch the message with the updated information
        data = await getData(data);
        waitTime = waitTime * waitMultiplier;
    }

    return data;
};


export const waitMs = async (ms: number) => {
    return new Promise((resolve, _) => setTimeout(resolve, ms));
};




// MORE FILESYSTEM STUFF


export const parseMetadataString = (metadata: string): { [key: string]: string } => {
    if (!metadata) return {};

    const output: { [key: string]: string } = {};
    for (const line of metadata.split("\n")) {
        if (!line.includes("=")) continue;

        const items = line.split(" = ");
        if (items.length < 2) continue;

        const value = safeTrim(items[1].replace(/"/g, ""));
        if (isEmpty(value) || value === "(") continue;

        // If all conditions to parse pass, save the key/value pair
        output[safeTrim(items[0])] = value;
    }

    return output;
};
</file>

<file path="new/serializers/AttachmentSerializer.ts">
// import { Server } from "@server";
import * as fs from "fs";
import * as base64 from "byte-base64";
import type { Metadata } from "../fileSystem/types";
import { FileSystem } from "../fileSystem";
import { 
    getAttachmentMetadata } from "../helpers/utils";
import type { AttachmentResponse } from "../types";
import { DEFAULT_ATTACHMENT_CONFIG } from "./constants";
import type { AttachmentSerializerMultiParams, AttachmentSerializerSingleParams } from "./types";
// import { AttachmentInterface } from "../interfaces/attachmentInterface";

export class AttachmentSerializer {
    
    static async serialize({
        attachment,
        config = DEFAULT_ATTACHMENT_CONFIG,
        isForNotification = false
    }: AttachmentSerializerSingleParams): Promise<AttachmentResponse> {
        return (
            await AttachmentSerializer.serializeList({
                attachments: [attachment],
                config: { ...DEFAULT_ATTACHMENT_CONFIG, ...config },
                isForNotification
            })
        )[0];
    }

    static async serializeList({
        attachments,
        config = DEFAULT_ATTACHMENT_CONFIG,
        isForNotification = false
    }: AttachmentSerializerMultiParams): Promise<AttachmentResponse[]> {
        return Promise.all(
            attachments.map(
                async attachment =>
                    await AttachmentSerializer.convert({
                        attachment,
                        config: { ...DEFAULT_ATTACHMENT_CONFIG, ...config },
                        isForNotification
                    })
            )
        );
    }

    private static async convert({
        attachment,
        config = DEFAULT_ATTACHMENT_CONFIG,
        isForNotification = false
    }: AttachmentSerializerSingleParams): Promise<AttachmentResponse> {
        let data: Uint8Array | string | null = null;
        let metadata: Metadata | null = null;

        // Get the fully qualified path
        let fPath = FileSystem.getRealPath(attachment.filePath);
        const mimeType = attachment.getMimeType();

        // If the attachment isn't finished downloading, the path will be null
        if (fPath) {
            try {
                // If we want to convert the attachment, do so here.
                // So long as we haven't done it yet.

                //  // TODO - turn back on convert below

                // if (config.convert && !fPath.includes(FileSystem.convertDir)) {
                //     const converters = [convertImage, convertAudio];
                //     for (const conversion of converters) {
                //         // Try to convert the attachments using available converters
                //         const newPath = await conversion(attachment, { originalMimeType: mimeType });
                //         if (newPath) {
                //             fPath = newPath;
                //             break;
                //         }
                //     }
                // }

                // If the attachment exists, do some things
                const exists = fs.existsSync(fPath);
                if (exists) {
                    // If we want data, get the data
                    if (config.loadData) {
                        data = Uint8Array.from(fs.readFileSync(fPath));
                    }

                    // Fetch the attachment metadata if there is a mimeType
                    if (config.loadMetadata) {
                        metadata = await getAttachmentMetadata(attachment);
                    }

                    // If there is no data, return null for the data
                    // Otherwise, convert it to a base64 string
                    if (data) {
                        data = base64.bytesToBase64(data as Uint8Array);
                    }
                }
            } catch (ex: any) {
                // Server().log(`Could not read file [${fPath}]: ${ex?.message ?? String(ex)}`, "error");
            }
        } else {
            // Server().log("Attachment hasn't been downloaded yet!", "debug");
        }

        let output: AttachmentResponse = {
            originalROWID: attachment.ROWID,
            guid: attachment.guid,
            uti: attachment.uti,
            mimeType: mimeType,
            transferName: attachment.transferName,
            totalBytes: attachment.totalBytes
        };

        if (!isForNotification) {
            output = {
                ...output,
                ...{
                    transferState: attachment.transferState,
                    isOutgoing: attachment.isOutgoing,
                    hideAttachment: attachment.hideAttachment,
                    isSticker: attachment.isSticker,
                    originalGuid: attachment.originalGuid,
                    hasLivePhoto: false,
                    // hasLivePhoto: !!AttachmentInterface.getLivePhotoPath(attachment)
                }
            };
        }

        if (config.includeMessageGuids) {
            output.messages = attachment.messages ? attachment.messages.map(item => item.guid) : [];
        }

        if (config.loadMetadata) {
            output = {
                ...output,
                ...{
                    height: (metadata?.height ?? 0) as number,
                    width: (metadata?.width ?? 0) as number,
                    metadata
                }
            };
        }

        if (config.loadData) {
            output.data = data as string;
        }

        return output;
    }
}
</file>

<file path="new/serializers/ChatSerializer.ts">
import type { ChatResponse } from "../types";
import { DEFAULT_CHAT_CONFIG, DEFAULT_HANDLE_CONFIG, DEFAULT_MESSAGE_CONFIG } from "./constants";
import type { ChatSerializerMutliParams, ChatSerializerSingleParams } from "./types";
import { MessageSerializer } from "./MessageSerializer";
import { HandleSerializer } from "./HandleSerializer";

export class ChatSerializer {
    static async serialize({
        chat,
        config = DEFAULT_CHAT_CONFIG,
        messageConfig = DEFAULT_MESSAGE_CONFIG,
        handleConfig = DEFAULT_HANDLE_CONFIG,
        isForNotification = false
    }: ChatSerializerSingleParams): Promise<ChatResponse> {
        return (
            await ChatSerializer.serializeList({
                chats: [chat],
                config: { ...DEFAULT_CHAT_CONFIG, ...config },
                messageConfig: { ...DEFAULT_MESSAGE_CONFIG, ...messageConfig },
                handleConfig: { ...DEFAULT_HANDLE_CONFIG, ...handleConfig },
                isForNotification
            })
        )[0];
    }

    static async serializeList({
        chats,
        config = DEFAULT_CHAT_CONFIG,
        messageConfig = DEFAULT_MESSAGE_CONFIG,
        handleConfig = DEFAULT_HANDLE_CONFIG,
        isForNotification = false
    }: ChatSerializerMutliParams): Promise<ChatResponse[]> {
        return Promise.all(
            chats.map(
                async chat =>
                    await ChatSerializer.convert({
                        chat,
                        config: { ...DEFAULT_CHAT_CONFIG, ...config },
                        messageConfig: { ...DEFAULT_MESSAGE_CONFIG, ...messageConfig },
                        handleConfig: { ...DEFAULT_HANDLE_CONFIG, ...handleConfig },
                        isForNotification
                    })
            )
        );
    }

    private static async convert({
        chat,
        config = DEFAULT_CHAT_CONFIG,
        messageConfig = DEFAULT_MESSAGE_CONFIG,
        handleConfig = DEFAULT_HANDLE_CONFIG,
        isForNotification = false
    }: ChatSerializerSingleParams): Promise<ChatResponse> {

        console.log('[ChatSerializer.convert]',{chat: JSON.stringify(chat, null, 2)});

        let output: ChatResponse = {
            originalROWID: chat.ROWID,
            guid: chat.guid,
            style: chat.style,
            chatIdentifier: chat.chatIdentifier,
            isArchived: chat.isArchived,
            displayName: chat.displayName
        };

        if (config.includeParticipants) {
            output.participants = await HandleSerializer.serializeList({
                handles: chat?.participants ?? [],
                config: {
                    ...handleConfig,
                    includeChats: false
                },
                messageConfig,
                chatConfig: config,
                isForNotification
            });
        }

        if (config.includeMessages) {
            output.messages = await MessageSerializer.serializeList({
                messages: chat?.messages ?? [],
                config: {
                    ...messageConfig,
                    includeChats: false
                },
                isForNotification
            });
        }

        if (!isForNotification) {
            output = {
                ...output,
                ...{
                    isFiltered: chat.isFiltered,
                    groupId: chat.groupId,
                    properties: chat.properties,
                    lastAddressedHandle: chat.lastAddressedHandle
                }
            };
        }

        return output;
    }
}
</file>

<file path="new/serializers/constants.ts">
export const DEFAULT_ATTACHMENT_CONFIG = {
    convert: false,
    loadData: false,
    loadMetadata: true,
    includeMessageGuids: false
};

export const DEFAULT_MESSAGE_CONFIG = {
    parseAttributedBody: false,
    parseMessageSummary: false,
    parsePayloadData: false,
    loadChatParticipants: true,
    includeChats: true,
    enforceMaxSize: false,
    // Max payload size is 4000 bytes
    // https://firebase.google.com/docs/cloud-messaging/concept-options#notifications_and_data_messages
    maxSizeBytes: 4000
};

export const DEFAULT_CHAT_CONFIG = {
    includeParticipants: true,
    includeMessages: false
};

export const DEFAULT_HANDLE_CONFIG = {
    includeChats: false,
    includeMessages: false
};
</file>

<file path="new/serializers/HandleSerializer.ts">
import type { HandleResponse } from "../types";
import type { HandleSerializerMutliParams, HandleSerializerSingleParams } from "./types";
import { DEFAULT_CHAT_CONFIG, DEFAULT_HANDLE_CONFIG, DEFAULT_MESSAGE_CONFIG } from "./constants";
import { MessageSerializer } from "./MessageSerializer";
import { ChatSerializer } from "./ChatSerializer";

export class HandleSerializer {
    static async serialize({
        handle,
        config = DEFAULT_HANDLE_CONFIG,
        messageConfig = DEFAULT_MESSAGE_CONFIG,
        chatConfig = DEFAULT_CHAT_CONFIG,
        isForNotification = false
    }: HandleSerializerSingleParams): Promise<HandleResponse> {
        return (
            await HandleSerializer.serializeList({
                handles: [handle],
                config: { ...DEFAULT_HANDLE_CONFIG, ...config },
                messageConfig: { ...DEFAULT_MESSAGE_CONFIG, ...messageConfig },
                chatConfig: { ...DEFAULT_CHAT_CONFIG, ...chatConfig },
                isForNotification
            })
        )[0];
    }

    static async serializeList({
        handles,
        config = DEFAULT_HANDLE_CONFIG,
        messageConfig = DEFAULT_MESSAGE_CONFIG,
        chatConfig = DEFAULT_CHAT_CONFIG,
        isForNotification = false
    }: HandleSerializerMutliParams): Promise<HandleResponse[]> {
        return Promise.all(
            handles.map(
                async handle =>
                    await HandleSerializer.convert({
                        handle,
                        config: { ...DEFAULT_HANDLE_CONFIG, ...config },
                        messageConfig: { ...DEFAULT_MESSAGE_CONFIG, ...messageConfig },
                        chatConfig: { ...DEFAULT_CHAT_CONFIG, ...chatConfig },
                        isForNotification
                    })
            )
        );
    }

    private static async convert({
        handle,
        config = DEFAULT_HANDLE_CONFIG,
        messageConfig = DEFAULT_MESSAGE_CONFIG,
        chatConfig = DEFAULT_CHAT_CONFIG,
        isForNotification = false
    }: HandleSerializerSingleParams): Promise<HandleResponse> {
        let output: HandleResponse = {
            originalROWID: handle.ROWID,
            address: handle.id,
            service: handle.service
        };

        if (config.includeChats) {
            output.chats = await ChatSerializer.serializeList({
                chats: handle?.chats ?? [],
                config: chatConfig,
                messageConfig,
                handleConfig: { includeChats: false, includeMessages: false },
                isForNotification
            });
        }

        if (config.includeMessages) {
            output.messages = await MessageSerializer.serializeList({
                messages: handle?.messages ?? [],
                config: messageConfig,
                isForNotification
            });
        }

        if (!isForNotification) {
            output = {
                ...output,
                ...{
                    uncanonicalizedId: handle.uncanonicalizedId,
                    country: handle.country
                }
            };
        }

        return output;
    }
}
</file>

<file path="new/serializers/MessageSerializer.ts">
// import { Server } from "@server";
import { isEmpty } from "../helpers/utils";
import { isMinHighSierra, isMinMonterey, isMinVentura } from "../env";
import type { HandleResponse, MessageResponse } from "../types";
// import { AttachmentSerializer } from "./AttachmentSerializer"; //Todo -reenable
import { ChatSerializer } from "./ChatSerializer";
import { HandleSerializer } from "./HandleSerializer";
import { DEFAULT_ATTACHMENT_CONFIG, DEFAULT_MESSAGE_CONFIG } from "./constants";
import type { MessageSerializerMultiParams, MessageSerializerSingleParams } from "./types";

export class MessageSerializer {
    static async serialize({
        message,
        config = DEFAULT_MESSAGE_CONFIG,
        attachmentConfig = DEFAULT_ATTACHMENT_CONFIG,
        isForNotification = false
    }: MessageSerializerSingleParams): Promise<MessageResponse> {
        return (
            await MessageSerializer.serializeList({
                messages: [message],
                config: { ...DEFAULT_MESSAGE_CONFIG, ...config },
                attachmentConfig: { ...DEFAULT_ATTACHMENT_CONFIG, ...attachmentConfig },
                isForNotification
            })
        )[0];
    }

    static async serializeList({
        messages,
        config = DEFAULT_MESSAGE_CONFIG,
        attachmentConfig = DEFAULT_ATTACHMENT_CONFIG,
        isForNotification = false
    }: MessageSerializerMultiParams): Promise<MessageResponse[]> {
        // Convert the messages to their serialized versions
        const messageResponses: MessageResponse[] = [];
        for (const message of messages) {
            messageResponses.push(
                await MessageSerializer.convert({
                    message: message,
                    config: { ...DEFAULT_MESSAGE_CONFIG, ...config },
                    attachmentConfig: { ...DEFAULT_ATTACHMENT_CONFIG, ...attachmentConfig },
                    isForNotification
                })
            );
        }

        // Handle fetching the chat participants with the messages (if requested)
        const chatCache: { [key: string]: HandleResponse[] } = {};
        // if (config.loadChatParticipants) {
        //     for (let i = 0; i < messages.length; i++) {
        //         // If there aren't any chats for this message, skip it
        //         if (isEmpty(messages[i]?.chats ?? [])) continue;

        //         // Iterate over the chats for this message and load the participants.
        //         // We only need to load the participants for group chats since DMs don't have them.
        //         // Once we load the chat participants for a chat, we will cache it to be used later.
        //         for (let k = 0; k < (messages[i]?.chats ?? []).length; i++) {
        //             // If it's not a group, skip it (style == 43; DM = 45)
        //             // Also skip it if there are already participants
        //             if (messages[i]?.chats[k].style !== 43 || isNotEmpty(messages[i]?.chats[k].participants)) continue;

        //             // Get the participants for this chat, or load it from our cache
        //             if (!Object.keys(chatCache).includes(messages[i]?.chats[k].guid)) {
        //                 const [chats, _] = await Server().iMessageRepo.getChats({
        //                     chatGuid: messages[i]?.chats[k].guid,
        //                     withParticipants: true
        //                 });
        //                 if (isNotEmpty(chats)) {
        //                     chatCache[messages[i]?.chats[k].guid] = await HandleSerializer.serializeList({
        //                         handles: chats[0].participants ?? [],
        //                         config: { includeChats: false, includeMessages: false }
        //                     });
        //                     messageResponses[i].chats[k].participants = chatCache[messages[i]?.chats[k].guid];
        //                 }
        //             } else {
        //                 messageResponses[i].chats[k].participants = chatCache[messages[i].chats[k].guid];
        //             }
        //         }
        //     }
        // }

        // The parse options are enforced _after_ the convert function is called.
        // This is so that we can properly extract the text from the attributed body
        // for those on macOS Ventura. Otherwise, set it to null to not clutter the payload.
        if (!config.parseAttributedBody || !config.parseMessageSummary || !config.parsePayloadData) {
            for (let i = 0; i < messageResponses.length; i++) {
                if (!config.parseAttributedBody && "attributedBody" in messageResponses[i]) {
                    messageResponses[i].attributedBody = null;
                }

                if (!config.parseMessageSummary && "messageSummaryInfo" in messageResponses[i]) {
                    messageResponses[i].messageSummaryInfo = null;
                }

                if (!config.parsePayloadData && "payloadData" in messageResponses[i]) {
                    messageResponses[i].payloadData = null;
                }
            }
        }

        if (config.enforceMaxSize) {
            const strData = JSON.stringify(messageResponses);
            const len = Buffer.byteLength(strData, "utf8");

            // If we've reached out max size, we need to clear the participants
            if (len > config.maxSizeBytes) {
                // Server().log(
                //     `MessageSerializer: Max size reached (${config.maxSizeBytes} bytes). Clearing participants.`,
                //     "debug"
                // );
                for (let i = 0; i < messageResponses.length; i++) {
                    for (let c = 0; c < (messageResponses[i]?.chats ?? []).length; c++) {
                        if (isEmpty(messageResponses[i].chats[c].participants)) continue;
                        messageResponses[i].chats[c].participants = [];
                    }
                }
            }
        }

        return messageResponses;
    }

    private static async convert({
        message,
        config = DEFAULT_MESSAGE_CONFIG,
        attachmentConfig = DEFAULT_ATTACHMENT_CONFIG,
        isForNotification = false
    }: MessageSerializerSingleParams): Promise<MessageResponse> {
        let output: MessageResponse = {
            originalROWID: message.ROWID,
            guid: message.guid,
            text: message.universalText(true),
            attributedBody: message.attributedBody,
            handle: message.handle
                ? await HandleSerializer.serialize({
                      handle: message.handle,
                      config: { includeChats: false, includeMessages: false }
                  })
                : null,
            handleId: message.handleId,
            otherHandle: message.otherHandle,
            // attachments: await AttachmentSerializer.serializeList({
            //     attachments: message.attachments ?? [],
            //     config: attachmentConfig,
            //     isForNotification
            // }),
            attachments: [],
            subject: message.subject,
            error: message.error,
            dateCreated: message.dateCreated ? message.dateCreated.getTime() : null,
            dateRead: message.dateRead ? message.dateRead.getTime() : null,
            dateDelivered: message.dateDelivered ? message.dateDelivered.getTime() : null,
            isDelivered: message.isDelivered,
            isFromMe: message.isFromMe,
            hasDdResults: message.hasDdResults,
            isArchived: message.isArchived,
            itemType: message.itemType,
            groupTitle: message.groupTitle,
            groupActionType: message.groupActionType,
            balloonBundleId: message.balloonBundleId,
            associatedMessageGuid: message.associatedMessageGuid,
            associatedMessageType: message.associatedMessageType,
            expressiveSendStyleId: message.expressiveSendStyleId,
            threadOriginatorGuid: message.threadOriginatorGuid,
            hasPayloadData: !!message.payloadData
        };

        // Non-essentials
        if (!isForNotification) {
            output = {
                ...output,
                ...{
                    country: message.country,
                    isDelayed: message.isDelayed,
                    isAutoReply: message.isAutoReply,
                    isSystemMessage: message.isSystemMessage,
                    isServiceMessage: message.isServiceMessage,
                    isForward: message.isForward,
                    threadOriginatorPart: message.threadOriginatorPart,
                    isCorrupt: message.isCorrupt,
                    datePlayed: message.datePlayed ? message.datePlayed.getTime() : null,
                    cacheRoomnames: message.cacheRoomnames,
                    isSpam: message.isSpam,
                    isExpired: message.isExpirable,
                    timeExpressiveSendPlayed: message.timeExpressiveSendPlayed
                        ? message.timeExpressiveSendPlayed.getTime()
                        : null,
                    isAudioMessage: message.isAudioMessage,
                    replyToGuid: message.replyToGuid,
                    shareStatus: message.shareStatus,
                    shareDirection: message.shareDirection
                }
            };

            if (isMinMonterey) {
                output = {
                    ...output,
                    ...{
                        wasDeliveredQuietly: message.wasDeliveredQuietly ?? false,
                        didNotifyRecipient: message.didNotifyRecipient ?? false
                    }
                };
            }
        }

        if (config.includeChats) {
            output.chats = await ChatSerializer.serializeList({
                chats: message?.chats ?? [],
                config: { includeParticipants: true, includeMessages: false },
                isForNotification
            });
        }

        if (isMinHighSierra) {
            output.messageSummaryInfo = message.messageSummaryInfo;
            output.payloadData = message.payloadData;
        }

        if (isMinVentura) {
            output = {
                ...output,
                ...{
                    dateEdited: message.dateEdited ? message.dateEdited.getTime() : null,
                    dateRetracted: message.dateRetracted ? message.dateRetracted.getTime() : null,
                    partCount: message.partCount
                }
            };
        }

        return output;
    }
}
</file>

<file path="new/serializers/types.ts">
import type { Attachment } from "../entities/Attachment";
import type { Chat } from "../entities/Chat";
import type { Message } from "../entities/Message";
import type { Handle } from "../entities/Handle";

export interface AttachmentSerializerParams {
    convert?: boolean;
    loadMetadata?: boolean;
    loadData?: boolean;
    includeMessageGuids?: boolean;
}

export interface ChatSerializerParams {
    includeParticipants?: boolean;
    includeMessages?: boolean;
}

export interface HandleSerializerParams {
    includeChats?: boolean;
    includeMessages?: boolean;
}

export interface MessageSerializerParams {
    parseAttributedBody?: boolean;
    parseMessageSummary?: boolean;
    parsePayloadData?: boolean;
    includeChats?: boolean;
    loadChatParticipants?: boolean;
    enforceMaxSize?: boolean;
    maxSizeBytes?: number;
}

export interface MessageSerializerSingleParams {
    message: Message;
    config?: MessageSerializerParams;
    attachmentConfig?: AttachmentSerializerParams;
    isForNotification?: boolean;
}

export interface MessageSerializerMultiParams {
    messages: Message[];
    config?: MessageSerializerParams;
    attachmentConfig?: AttachmentSerializerParams;
    isForNotification?: boolean;
}

export interface AttachmentSerializerSingleParams {
    attachment: Attachment;
    config?: AttachmentSerializerParams;
    messageConfig?: MessageSerializerParams;
    isForNotification?: boolean;
}

export interface AttachmentSerializerMultiParams {
    attachments: Attachment[];
    config?: AttachmentSerializerParams;
    messageConfig?: MessageSerializerParams;
    isForNotification?: boolean;
}

export interface ChatSerializerSingleParams {
    chat: Chat;
    config?: ChatSerializerParams;
    messageConfig?: MessageSerializerParams;
    handleConfig?: HandleSerializerParams;
    isForNotification?: boolean;
}

export interface ChatSerializerMutliParams {
    chats: Chat[];
    config?: ChatSerializerParams;
    messageConfig?: MessageSerializerParams;
    handleConfig?: HandleSerializerParams;
    isForNotification?: boolean;
}

export interface HandleSerializerSingleParams {
    handle: Handle;
    config?: HandleSerializerParams;
    messageConfig?: MessageSerializerParams;
    chatConfig?: ChatSerializerParams;
    isForNotification?: boolean;
}

export interface HandleSerializerMutliParams {
    handles: Handle[];
    config?: HandleSerializerParams;
    messageConfig?: MessageSerializerParams;
    chatConfig?: ChatSerializerParams;
    isForNotification?: boolean;
}
</file>

<file path="new/env.ts">
import { isMacOSVersionGreaterThanOrEqualTo } from "macos-version";

export const isMinSequoia = isMacOSVersionGreaterThanOrEqualTo("15.0");
export const isMinSonoma = isMacOSVersionGreaterThanOrEqualTo("14.0");
export const isMinVentura = isMacOSVersionGreaterThanOrEqualTo("13.0");
export const isMinMonterey = isMacOSVersionGreaterThanOrEqualTo("12.0");
export const isMinBigSur = isMacOSVersionGreaterThanOrEqualTo("11.0");
export const isMinCatalina = isMacOSVersionGreaterThanOrEqualTo("10.15");
export const isMinMojave = isMacOSVersionGreaterThanOrEqualTo("10.14");
export const isMinHighSierra = isMacOSVersionGreaterThanOrEqualTo("10.13");
export const isMinSierra = isMacOSVersionGreaterThanOrEqualTo("10.12");
</file>

<file path="new/transformers.ts">
import { type ValueTransformer } from "typeorm";

export const BooleanTransformer: ValueTransformer = {
    from: dbValue => Boolean(dbValue),
    to: entityValue => Number(entityValue)
};

import { convertDateTo2001Time, getDateUsing2001 } from "./helpers/dateUtils";
import { convertAttributedBody } from "./helpers/utils";
export const MessagesDateTransformer: ValueTransformer = {
    from: dbValue => getDateUsing2001(dbValue),
    to: entityValue => convertDateTo2001Time(entityValue)
};


export const ReactionIdToString: { [key: string]: string } = {
    0: null,
    1000: "sticker",
    2000: "love",
    2001: "like",
    2002: "dislike",
    2003: "laugh",
    2004: "emphasize",
    2005: "question",
    3000: "-love",
    3001: "-like",
    3002: "-dislike",
    3003: "-laugh",
    3004: "-emphasize",
    3005: "-question"
};

export const ReactionStringToId: { [key: string]: number } = {
    sticker: 1000,
    love: 2000,
    like: 2001,
    dislike: 2002,
    laugh: 2003,
    emphasize: 2004,
    question: 2005,
    "-love": 3000,
    "-like": 3001,
    "-dislike": 3002,
    "-laugh": 3003,
    "-emphasize": 3004,
    "-question": 3005
};

export const MessageTypeTransformer: ValueTransformer = {
    from: (dbValue: number) =>
        Object.keys(ReactionIdToString).includes(dbValue.toString())
            ? ReactionIdToString[dbValue.toString()]
            : dbValue.toString(),
    to: entityValue => ReactionStringToId[entityValue] ?? 0
};


export const AttributedBodyTransformer: ValueTransformer = {
    from: dbValue => convertAttributedBody(dbValue),
    to: _ => null
};
</file>

<file path="new/types.ts">
import { NSAttributedString } from "node-typedstream";

export type ServerMetadataResponse = {
    computer_id: string;
    os_version: string;
    server_version: string;
    private_api: boolean;
    helper_connected: boolean;
    proxy_service: string;
    detected_icloud: string;
    detected_imessage: string;
    macos_time_sync: number | null;
    local_ipv4s: string[];
    local_ipv6s: string[];
};

/**
 * ITEM TYPES:
 * 0: Text
 * 1: Removal of person from conversation (groupActionType == 1)
 * 1: Adding of person to conversation (groupActionType == 0)
 * 2: Group Name Change
 * 3: Someone left the conversation (handle_id shows who)
 */
export type MessageResponse = {
    originalROWID: number;
    tempGuid?: string;
    guid: string;
    text: string;
    attributedBody?: NSAttributedString[];
    messageSummaryInfo?: NodeJS.Dict<any>[];
    handle?: HandleResponse | null;
    handleId: number;
    otherHandle: number;
    chats?: ChatResponse[];
    attachments?: AttachmentResponse[];
    subject: string;
    country?: string;
    error: number;
    dateCreated: number;
    dateRead: number | null;
    dateDelivered: number | null;
    isFromMe: boolean;
    isDelayed?: boolean;
    isDelivered?: boolean;
    isAutoReply?: boolean;
    isSystemMessage?: boolean;
    isServiceMessage?: boolean;
    isForward?: boolean;
    isArchived: boolean;
    hasDdResults?: boolean;
    cacheRoomnames?: string | null;
    isAudioMessage?: boolean;
    datePlayed?: number | null;
    itemType: number;
    groupTitle: string | null;
    groupActionType: number;
    isExpired?: boolean;
    balloonBundleId: string | null;
    associatedMessageGuid: string | null;
    associatedMessageType: string | null;
    expressiveSendStyleId: string | null;
    timeExpressiveSendPlayed?: number | null;
    replyToGuid?: string | null;
    isCorrupt?: boolean;
    isSpam?: boolean;
    threadOriginatorGuid?: string | null;
    threadOriginatorPart?: string | null;
    dateRetracted?: number | null;
    dateEdited?: number | null;
    partCount?: number | null;
    payloadData?: NodeJS.Dict<any>[];
    hasPayloadData?: boolean;
    wasDeliveredQuietly?: boolean;
    didNotifyRecipient?: boolean;
    shareStatus?: number | null;
    shareDirection?: number | null;
};

export type HandleResponse = {
    originalROWID: number;
    messages?: MessageResponse[];
    chats?: ChatResponse[];
    address: string;
    service: string;
    country?: string;
    uncanonicalizedId?: string;
};

export type ChatResponse = {
    originalROWID: number;
    guid: string;
    participants?: HandleResponse[];
    messages?: MessageResponse[];
    lastMessage?: MessageResponse;
    properties?: NodeJS.Dict<any>[] | null;
    style: number;
    chatIdentifier: string;
    isArchived: boolean;
    isFiltered?: boolean;
    displayName: string;
    groupId?: string;
    lastAddressedHandle?: string | null;
};

export type AttachmentResponse = {
    originalROWID: number;
    guid: string;
    messages?: string[];
    data?: string; // Base64 string
    blurhash?: string;
    height?: number;
    width?: number;
    uti: string;
    mimeType: string;
    transferState?: number;
    totalBytes: number;
    isOutgoing?: boolean;
    transferName: string;
    isSticker?: boolean;
    hideAttachment?: boolean;
    originalGuid?: string;
    metadata?: { [key: string]: string | boolean | number };
    hasLivePhoto?: boolean;
};

export type ValidTapback = "love" | "like" | "dislike" | "laugh" | "emphasize" | "question";
export type ValidRemoveTapback = "-love" | "-like" | "-dislike" | "-laugh" | "-emphasize" | "-question";
export enum ProgressStatus {
    NOT_STARTED = "NOT_STARTED",
    IN_PROGRESS = "IN_PROGRESS",
    COMPLETED = "COMPLETED",
    FAILED = "FAILED"
}
</file>

<file path="webhook/index.ts">
/*****************************************************************
 *  LOOPMESSAGE  WEBHOOK  ADAPTER    v2
 *****************************************************************/

import { randomUUID } from "crypto";
import type { MessageResponse, ChatResponse } from "../new/types";
import { DataSource } from "typeorm";

type LoopAlert =
  | "message_inbound"
  | "message_sent"
  | "message_failed"
  | "message_reaction";

const REACTION_MAP = {
  love: "love",
  like: "like",
  dislike: "dislike",
  laugh: "laugh",
  emphasize: "exclaim",
  question: "question"
} as const;

const deliveryType = (svc?: string) =>
  svc?.toLowerCase() === "sms" ? "sms" : "imessage";

const baseFields = (msg: MessageResponse) => ({
  webhook_id : randomUUID(),
  api_version: "1.0",
  message_id : msg.guid,
  recipient  : msg.handle?.address ?? "unknown",
  delivery_type: deliveryType(msg.service),
  text       : msg.text ?? undefined,
  subject    : msg.subject ?? undefined,
  group      : buildGroup(msg.chats?.[0])
});

function buildGroup(chat?: ChatResponse) {
    console.log({chat: JSON.stringify(chat, null, 2)});
  if (!chat || chat.style !== 43) return undefined;
  return {
    group_id    : chat.guid,
    name        : chat.displayName ?? undefined,
    participants: (chat.participants ?? []).map(p => p.address)
  };
}

function detectMessageType(m: MessageResponse) {
  if (m.associatedMessageType) return "reaction";
  if (m.isAudioMessage)        return "audio";
  if (m.attachments?.length)   return "attachments";
  if (m.balloonBundleId?.includes("Sticker")) return "sticker";
  return "text";
}

/**
 * Build webhook payload for *one* serialized Message.
 */
export async function buildLoopPayload(
  m: MessageResponse,
  db: DataSource
): Promise<Record<string, any>> {
  // ----- 1. TAP-BACKS ------------------------------------------------
  if (m.associatedMessageType) {
    return {
      ...baseFields(m),
      alert_type : "message_reaction" satisfies LoopAlert,
      message_type: "reaction",
      reaction   : REACTION_MAP[m.associatedMessageType.replace(/^-/, "") as keyof typeof REACTION_MAP] ?? "unknown",
      thread_id  : m.threadOriginatorGuid ?? undefined
    };
  }

  // Determine direction
  const inbound = !m.isFromMe;
  const alert: LoopAlert = inbound ? "message_inbound" : "message_sent";

  const payload: Record<string, any> = {
    ...baseFields(m),
    alert_type : alert,
    message_type: detectMessageType(m),
    thread_id  : m.threadOriginatorGuid ?? undefined
  };

  /********* fields common to *both* inbound & sent **********/
  if (m.attachments?.length) {
    payload.attachments = m.attachments.map(a => buildDownloadURL(a.guid));
  }

  /********* extra fields only LoopMessage expects for sent *******/
  if (!inbound) {
    // You could look at m.isDelivered / m.dateDelivered to refine this
    payload.success = true;
  }

  return payload;
}

/* --- helpers ----------------------------------------------------- */
function buildDownloadURL(guid: string) {
  return `file:///Attachments/${guid}`;        // swap for real CDN/S3 URL
}
</file>

<file path=".gitignore">
# Based on https://raw.githubusercontent.com/github/gitignore/main/Node.gitignore

# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Caches

.cache

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

*.tgz

# Yarn Integrity file

.yarn-integrity

# dotenv environment variable files

.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)

.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

# IntelliJ based IDEs
.idea

# Finder (MacOS) folder config
.DS_Store
</file>

<file path="env.ts">
import { isMacOSVersionGreaterThanOrEqualTo } from "macos-version";

export const isMinSequoia = isMacOSVersionGreaterThanOrEqualTo("15.0");
export const isMinSonoma = isMacOSVersionGreaterThanOrEqualTo("14.0");
export const isMinVentura = isMacOSVersionGreaterThanOrEqualTo("13.0");
export const isMinMonterey = isMacOSVersionGreaterThanOrEqualTo("12.0");
export const isMinBigSur = isMacOSVersionGreaterThanOrEqualTo("11.0");
export const isMinCatalina = isMacOSVersionGreaterThanOrEqualTo("10.15");
export const isMinMojave = isMacOSVersionGreaterThanOrEqualTo("10.14");
export const isMinHighSierra = isMacOSVersionGreaterThanOrEqualTo("10.13");
export const isMinSierra = isMacOSVersionGreaterThanOrEqualTo("10.12");
</file>

<file path="events.ts">
export const SCHEDULED_MESSAGE_ERROR = "scheduled-message-error";
export const SCHEDULED_MESSAGE_SENT = "scheduled-message-sent";
export const SCHEDULED_MESSAGE_DELETED = "scheduled-message-deleted";
export const SCHEDULED_MESSAGE_UPDATED = "scheduled-message-updated";
export const SCHEDULED_MESSAGE_CREATED = "scheduled-message-created";
export const NEW_MESSAGE = "new-message";
export const MESSAGE_SEND_ERROR = "message-send-error";
export const MESSAGE_UPDATED = "updated-message";
export const NEW_SERVER = "new-server";
export const PARTICIPANT_REMOVED = "participant-removed";
export const PARTICIPANT_ADDED = "participant-added";
export const PARTICIPANT_LEFT = "participant-left";
export const GROUP_ICON_CHANGED = "group-icon-changed";
export const GROUP_ICON_REMOVED = "group-icon-removed";
export const CHAT_READ_STATUS_CHANGED = "chat-read-status-changed";
export const HELLO_WORLD = "hello-world";
export const TYPING_INDICATOR = "typing-indicator";
export const SERVER_UPDATE = "server-update";
export const SERVER_UPDATE_DOWNLOADING = "server-update-downloading";
export const SERVER_UPDATE_INSTALLING = "server-update-installing";
export const GROUP_NAME_CHANGE = "group-name-change";
export const INCOMING_FACETIME = "incoming-facetime";
export const SETTINGS_BACKUP_CREATED = "settings-backup-created";
export const SETTINGS_BACKUP_DELETED = "settings-backup-deleted";
export const SETTINGS_BACKUP_UPDATED = "settings-backup-updated";
export const THEME_BACKUP_CREATED = "theme-backup-created";
export const THEME_BACKUP_DELETED = "theme-backup-deleted";
export const THEME_BACKUP_UPDATED = "theme-backup-updated";
export const IMESSAGE_ALIASES_REMOVED = "imessage-aliases-removed";
export const FT_CALL_STATUS_CHANGED = "ft-call-status-changed";
export const NEW_FINDMY_LOCATION = "new-findmy-location";
</file>

<file path="index.ts">
import "reflect-metadata";

// SCRIPT START
// Necessary for TypeORM
import { DataSource, Brackets } from "typeorm";

// --- Assume these files are copied into your script's directory or paths are adjusted ---
// You would need to ensure all transitive dependencies of these files are also available.

// ENTITIES (FROM: packages/server/src/server/databases/imessage/entity/)
import { Message } from './new/entities/Message'; // Assume Message.ts is in the same directory or path adjusted
import { Handle } from './new/entities/Handle';   // Assume Handle.ts is in the same directory or path adjusted
import { Chat } from './new/entities/Chat';     // Assume Chat.ts is in the same directory or path adjusted
import { Attachment } from './new/entities/Attachment'; // Assume Attachment.ts is in the same directory or path adjusted

// HELPERS (FROM: packages/server/src/server/databases/imessage/helpers/)
import { convertDateTo2001Time } from './new/helpers/dateUtils'; // Assume dateUtil.ts is in the same directory or path adjusted

// SERIALIZERS (FROM: packages/server/src/server/api/serializers/)
import { MessageSerializer } from './new/serializers/MessageSerializer'; // Assume MessageSerializer.ts is in the same directory or path adjusted
// MessageSerializer itself depends on HandleSerializer, ChatSerializer, AttachmentSerializer.
// For this script to fully work, those would need to be present too.
// We will make serializer configs minimal to reduce deep dependencies for this example.
import { DEFAULT_ATTACHMENT_CONFIG, DEFAULT_MESSAGE_CONFIG } from './new/serializers/constants';
import { buildLoopPayload } from "./webhook";
import type { MessageResponse } from "./new/types";

// --- END OF ASSUMED COPIED/IMPORTED FILES ---


// --- CORE LOGIC ---

const DB_PATH = `${process.env.HOME}/Library/Messages/chat.db`;
let dataSource: DataSource | null = null;

// Minimal configuration for MessageSerializer for this script's purpose
const SCRIPT_MESSAGE_SERIALIZER_CONFIG = {
    ...DEFAULT_MESSAGE_CONFIG,
    loadChatParticipants: false, // Avoids needing full participant loading logic for simplicity
    includeChats: true,          // We want to know which chat it belongs to
    enforceMaxSize: false,
    parseAttributedBody: true,   // For universalText
    parseMessageSummary: true,   // For edits/unsends
    parsePayloadData: false      // Usually not critical for basic display
};

const SCRIPT_ATTACHMENT_SERIALIZER_CONFIG = {
    ...DEFAULT_ATTACHMENT_CONFIG,
    loadData: false,             // Don't load attachment bytes
    loadMetadata: true
};



/**
 * Initializes a connection to the iMessage database.
 */
async function initializeDatabase(): Promise<boolean> {
    try {
        dataSource = new DataSource({
            name: "iMessageMinimalScript",
            type: "better-sqlite3",
            database: DB_PATH,
            entities: [Message, Handle, Chat, Attachment],
            // Transformers are part of the entities, so they'll be used automatically
            // logging: ["query", "error"] // Uncomment for debugging DB queries
        });
        await dataSource.initialize();
        console.log("Successfully connected to iMessage database.");
        return true;
    } catch (e: any) {
        console.error(`Failed to connect to iMessage database at ${DB_PATH}:`, e.message);
        console.error("Please ensure you have Full Disk Access for the terminal/application running this script.");
        dataSource = null;
        return false;
    }
}

/**
 * Fetches new incoming messages from the database since a given timestamp.
 * This is a simplified version of what MessagePoller and MessageRepository do.
 */
async function getNewIncomingMessages(afterTimestamp: Date): Promise<Message[]> {
    if (!dataSource || !dataSource.isInitialized) {
        console.error("Database not initialized. Call initializeDatabase() first.");
        return [];
    }

    // Look back a bit further and then filter precisely in JS to leverage indexed `dateCreated`
    // This is an optimization from the original codebase.
    const lookbackBufferMs = 15 * 60 * 1000; // 15 minutes buffer for updates to slightly older messages
    const queryStartDate = new Date(afterTimestamp.getTime() - lookbackBufferMs);

    const query = dataSource
        .getRepository(Message)
        .createQueryBuilder("message")
        .leftJoinAndSelect("message.handle", "handle") // For sender info
        .leftJoinAndSelect("message.attachments", "attachment") // For attachment info
        .innerJoinAndSelect("message.chats", "chat") // Messages always belong to a chat
        .where("message.is_from_me = :isFromMe", { isFromMe: 0 }) // Only incoming messages
        .andWhere(
            new Brackets(qb => {
                // Primary condition: new messages created after the timestamp
                qb.where("message.date >= :afterDate", { afterDate: convertDateTo2001Time(queryStartDate) })
                    // OR messages edited after the timestamp (for updates like edits/unsends)
                    .orWhere("message.date_edited >= :afterDateEdited", { afterDateEdited: convertDateTo2001Time(queryStartDate) })
            })
        )
        .orderBy("message.date", "ASC"); // Process in chronological order

    const dbMessages = await query.getMany();

    // Precise filtering for "newness"
    const actualAfterTime = afterTimestamp.getTime();
    return dbMessages.filter(msg => {
        const createdTime = msg.dateCreated?.getTime() ?? 0;
        const editedTime = msg.dateEdited?.getTime() ?? 0;

        // Is it a brand new message received after our last check?
        const isNew = createdTime >= actualAfterTime;
        // Or, is it an older message that was edited/unsent after our last check?
        const isRecentUpdate = editedTime >= actualAfterTime || (msg.hasUnsentParts && createdTime >= queryStartDate.getTime());

        return isNew || isRecentUpdate;
    });
}


async function getAllMessages(afterTimestamp: Date): Promise<Message[]> {
    if (!dataSource || !dataSource.isInitialized) {
        console.error("Database not initialized. Call initializeDatabase() first.");
        return [];
    }

    const lookbackBufferMs = 15 * 60 * 1000;
    const queryStartDate = new Date(afterTimestamp.getTime() - lookbackBufferMs);

    const query = dataSource
        .getRepository(Message)
        .createQueryBuilder("message")
        .leftJoinAndSelect("message.handle", "handle")
        .leftJoinAndSelect("message.attachments", "attachment")
        .innerJoinAndSelect("message.chats", "chat")
        .leftJoinAndSelect("chat.participants", "chatParticipants")
        .andWhere(
            new Brackets(qb => {
                qb.where("message.date >= :afterDate", { afterDate: convertDateTo2001Time(queryStartDate) })
                    .orWhere("message.date_edited >= :afterDateEdited", { afterDateEdited: convertDateTo2001Time(queryStartDate) });
            })
        )
        .orderBy("message.date", "ASC");

    const dbMessages = await query.getMany();

    const actualAfterTime = afterTimestamp.getTime();
    return dbMessages.filter(msg => {
        const createdTime = msg.dateCreated?.getTime() ?? 0;
        const editedTime = msg.dateEdited?.getTime() ?? 0;

        const isNew = createdTime >= actualAfterTime;
        const isRecentUpdate = editedTime >= actualAfterTime || (msg.hasUnsentParts && createdTime >= queryStartDate.getTime());

        return isNew || isRecentUpdate;
    });
}

/**
 * Main polling function.
 */
async function pollForNewMessages(lastPollTime: Date): Promise<Date> {
    if (!dataSource) return lastPollTime;

    // console.log(`[${new Date().toISOString()}] Checking for new messages since ${lastPollTime.toISOString()}`);
    const newMessages = await getAllMessages(lastPollTime);

    if (newMessages.length > 0) {
        console.log(`Found ${newMessages.length} new/updated incoming message(s):`);
        for (const msg of newMessages) {
            console.log({msg: JSON.stringify(msg, null, 2)});
            try {
                // Transform the Message entity into a MessageResponse-like object
                const serializedMsg = await MessageSerializer.serialize({
                    message: msg,
                    config: SCRIPT_MESSAGE_SERIALIZER_CONFIG,
                    attachmentConfig: SCRIPT_ATTACHMENT_SERIALIZER_CONFIG,
                    isForNotification: false // Get full details
                });

                const payload = await buildLoopPayload(serializedMsg, dataSource);
                console.log({payload: JSON.stringify(payload, null, 2)});

                // prettyPrintMessage(serializedMsg, dataSource);
            } catch (transformError: any) {
                console.error(`Error transforming message ${msg.guid}: ${transformError.message}`);
            }
        }
        console.log("  ----------------------------------------");
    } else {
        // console.log("No new messages found.");
    }

    return new Date(); // Return current time as the new "last poll time"
}

/**
 * Entry point.
 */
async function run() {
    if (!await initializeDatabase()) {
        return;
    }

    // Set initial poll time (e.g., 5 minutes ago, or from a saved state)
    let lastTimestamp = new Date(Date.now() - (5 * 60 * 1000)); // 5 minutes ago

    // Poll immediately, then set an interval
    lastTimestamp = await pollForNewMessages(lastTimestamp);
    setInterval(async () => {
        lastTimestamp = await pollForNewMessages(lastTimestamp);
    }, 2 * 1000); // Poll every 2 seconds

    // Keep the script alive. In a real app, you'd have a proper shutdown.
    // process.stdin.resume();
    process.on('SIGINT', async () => {
        console.log("SIGINT received, closing database connection...");
        if (dataSource && dataSource.isInitialized) {
            await dataSource.destroy();
        }
        process.exit(0);
    });
}


run().catch(console.error);
// SCRIPT END


function prettyPrintMessage(m: MessageResponse, db: DataSource) {
    // ---------- helpers ----------
    const deliveryType = m.handle?.service?.toLowerCase() === "sms" ? "SMS" : "iMessage";
    const direction    = m.isFromMe ? "SENT" : "INBOUND";
  
    const getMessageType = () => {
      if (m.associatedMessageType)          return "reaction";
      if (m.isAudioMessage)                 return "audio";
      if (m.attachments?.length)            return "attachments";
      if (m.balloonBundleId?.includes("Sticker")) return "sticker";
      return "text";
    };
  
    const msgType = getMessageType();
  
    // ---------- header line ----------
    console.log("  ----------------------------------------");
    console.log(
      `[${direction}] (${deliveryType}) <${msgType}>  GUID:${m.guid}`
    );
  
    // ---------- basic fields ----------
    console.log(`  From       : ${m.handle?.address ?? "Unknown"}`);
    console.log(`  Date       : ${new Date(m.dateCreated).toLocaleString()}`);
    if (m.text) console.log(`  Text       : "${m.text}"`);
    if (m.subject) console.log(`  Subject    : "${m.subject}"`);
    if (m.attachments?.length)
      console.log(`  Attachments: ${m.attachments.length}`);
  
    // ---------- reactions ----------
    if (msgType === "reaction") {
      const reactedTo = m.associatedMessageGuid?.replace(/^p:\d+\//, "");
      console.log(`  Reaction   : ${m.associatedMessageType}`);
      console.log(`  On message : ${reactedTo}`);
  
      // (optional) fetch original text for context
      if (reactedTo) {
        db.getRepository(Message)
          .findOneBy({ guid: reactedTo })
          .then(orig =>
            console.log(
              `               "${orig?.universalText?.() ?? "<No Text>"}"`
            )
          )
          .catch(() => {});
      }
    }
  
    // ---------- replies ----------
    // Apple sets replyToGuid even for some reactions, so rely on threadOriginatorGuid
    const threadId = m.threadOriginatorGuid ?? m.replyToGuid;
    if (threadId && msgType !== "reaction") {
      console.log(`  Reply-to   : ${threadId}`);
      db.getRepository(Message)
        .findOneBy({ guid: threadId })
        .then(orig =>
          console.log(
            `               "${orig?.universalText?.() ?? "<No Text>"}"`
          )
        )
        .catch(() => {});
    }
  
    // ---------- status flags ----------
    if (m.dateEdited)   console.log(`   Edited   : ${new Date(m.dateEdited).toLocaleString()}`);
    if (m.dateRetracted)console.log(`   Unsent   : ${new Date(m.dateRetracted).toLocaleString()}`);
    if (m.isArchived)   console.log(`   Archived`);
    if (!m.isFromMe && m.wasDeliveredQuietly) console.log("   Delivered Quietly");
  
    console.log("  ----------------------------------------\n");
  }
</file>

<file path="package.json">
{
  "dependencies": {
    "@firebase/util": "^1.12.0",
    "better-sqlite3": "^11.10.0",
    "blurhash": "^2.0.5",
    "byte-base64": "^1.1.0",
    "compare-versions": "^6.1.1",
    "conditional-decorator": "^0.1.7",
    "electron": "^36.4.0",
    "electron-log": "^5.4.0",
    "google-libphonenumber": "^3.2.41",
    "macos-version": "^6.0.0",
    "mime-types": "^3.0.1",
    "node-mac-permissions": "^2.5.0",
    "node-typedstream": "^1.4.1",
    "read-chunk": "^5.0.0",
    "typeorm": "^0.3.24",
    "vcf": "^2.1.2"
  },
  "devDependencies": {
    "typescript": "^5.4.5"
  },
  "scripts": {
    "build": "tsc",
    "start": "npx tsx index.ts",
    "dev": "npx tsx index.ts"
  }
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    // Enable latest features
    "lib": [
      "ESNext",
      "DOM"
    ],
    "target": "ESNext",
    "module": "ESNext",
    "moduleDetection": "force",
    "jsx": "react-jsx",
    "allowJs": true,
    // Bundler mode
    "moduleResolution": "bundler",
    "verbatimModuleSyntax": true,
    "noEmit": false,
    "noEmitOnError": false,
    "outDir": "./dist",
    // Best practices
    "strict": true,
    "skipLibCheck": true,
    "noFallthroughCasesInSwitch": true,
    // Some stricter flags (disabled by default)
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noPropertyAccessFromIndexSignature": false,
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true

    "baseUrl": ".", // This sets the base directory for paths
    "paths": {
      "@server/*": [
        "./*"
      ],
      "@server": [
        "./server.ts"
      ]
    }
  }
}
</file>

<file path="types.ts">
import { NSAttributedString } from "node-typedstream";

export type ServerMetadataResponse = {
    computer_id: string;
    os_version: string;
    server_version: string;
    private_api: boolean;
    helper_connected: boolean;
    proxy_service: string;
    detected_icloud: string;
    detected_imessage: string;
    macos_time_sync: number | null;
    local_ipv4s: string[];
    local_ipv6s: string[];
};

/**
 * ITEM TYPES:
 * 0: Text
 * 1: Removal of person from conversation (groupActionType == 1)
 * 1: Adding of person to conversation (groupActionType == 0)
 * 2: Group Name Change
 * 3: Someone left the conversation (handle_id shows who)
 */
export type MessageResponse = {
    originalROWID: number;
    tempGuid?: string;
    guid: string;
    text: string;
    attributedBody?: NSAttributedString[];
    messageSummaryInfo?: NodeJS.Dict<any>[];
    handle?: HandleResponse | null;
    handleId: number;
    otherHandle: number;
    chats?: ChatResponse[];
    attachments?: AttachmentResponse[];
    subject: string;
    country?: string;
    error: number;
    dateCreated: number;
    dateRead: number | null;
    dateDelivered: number | null;
    isFromMe: boolean;
    isDelayed?: boolean;
    isDelivered?: boolean;
    isAutoReply?: boolean;
    isSystemMessage?: boolean;
    isServiceMessage?: boolean;
    isForward?: boolean;
    isArchived: boolean;
    hasDdResults?: boolean;
    cacheRoomnames?: string | null;
    isAudioMessage?: boolean;
    datePlayed?: number | null;
    itemType: number;
    groupTitle: string | null;
    groupActionType: number;
    isExpired?: boolean;
    balloonBundleId: string | null;
    associatedMessageGuid: string | null;
    associatedMessageType: string | null;
    expressiveSendStyleId: string | null;
    timeExpressiveSendPlayed?: number | null;
    replyToGuid?: string | null;
    isCorrupt?: boolean;
    isSpam?: boolean;
    threadOriginatorGuid?: string | null;
    threadOriginatorPart?: string | null;
    dateRetracted?: number | null;
    dateEdited?: number | null;
    partCount?: number | null;
    payloadData?: NodeJS.Dict<any>[];
    hasPayloadData?: boolean;
    wasDeliveredQuietly?: boolean;
    didNotifyRecipient?: boolean;
    shareStatus?: number | null;
    shareDirection?: number | null;
};

export type HandleResponse = {
    originalROWID: number;
    messages?: MessageResponse[];
    chats?: ChatResponse[];
    address: string;
    service: string;
    country?: string;
    uncanonicalizedId?: string;
};

export type ChatResponse = {
    originalROWID: number;
    guid: string;
    participants?: HandleResponse[];
    messages?: MessageResponse[];
    lastMessage?: MessageResponse;
    properties?: NodeJS.Dict<any>[] | null;
    style: number;
    chatIdentifier: string;
    isArchived: boolean;
    isFiltered?: boolean;
    displayName: string;
    groupId?: string;
    lastAddressedHandle?: string | null;
};

export type AttachmentResponse = {
    originalROWID: number;
    guid: string;
    messages?: string[];
    data?: string; // Base64 string
    blurhash?: string;
    height?: number;
    width?: number;
    uti: string;
    mimeType: string;
    transferState?: number;
    totalBytes: number;
    isOutgoing?: boolean;
    transferName: string;
    isSticker?: boolean;
    hideAttachment?: boolean;
    originalGuid?: string;
    metadata?: { [key: string]: string | boolean | number };
    hasLivePhoto?: boolean;
};

export type ValidTapback = "love" | "like" | "dislike" | "laugh" | "emphasize" | "question";
export type ValidRemoveTapback = "-love" | "-like" | "-dislike" | "-laugh" | "-emphasize" | "-question";
export enum ProgressStatus {
    NOT_STARTED = "NOT_STARTED",
    IN_PROGRESS = "IN_PROGRESS",
    COMPLETED = "COMPLETED",
    FAILED = "FAILED"
}
</file>

</files>
